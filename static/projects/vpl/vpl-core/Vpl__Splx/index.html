<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Vpl__Splx (vpl-core.Vpl__Splx)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">vpl-core</a> &#x00BB; Vpl__Splx</nav><h1>Module <code>Vpl__Splx</code></h1><p>This module implements a feasibility-only simplex algorithm. The basis for the algorithm comes from the article &quot;Integrating simplex with DPLL(T)&quot; published by Bruno Dutertre and Leonardo de Moura in 2006 as an SRI International technical report. The interface of this module needs a fair amount of user-friendliness.</p><p><em>Remarks</em>. This module works only with variables of <span class="xref-unresolved" title="unresolved reference to &quot;Var.Positive&quot;"><code>Var</code>.Positive</span>. Its implementation directly depends on the data structure <code>Rtree</code>.</p></header><dl><dt class="spec type" id="type-bnd_t"><a href="#type-bnd_t" class="anchor"></a><code><span class="keyword">type</span> bnd_t</code><code> = </code><code>{</code><table class="record"><tr id="type-bnd_t.id" class="anchored"><td class="def field"><a href="#type-bnd_t.id" class="anchor"></a><code>id : int;</code></td></tr><tr id="type-bnd_t.scale" class="anchored"><td class="def field"><a href="#type-bnd_t.scale" class="anchor"></a><code>scale : <a href="../Vpl/Scalar/Rat/index.html#type-t">Vpl.Scalar.Rat.t</a>;</code></td></tr><tr id="type-bnd_t.bv" class="anchored"><td class="def field"><a href="#type-bnd_t.bv" class="anchor"></a><code>bv : <a href="../Vpl/Scalar/Symbolic/index.html#type-t">Vpl.Scalar.Symbolic.t</a>;</code></td></tr></table><code>}</code></dt><dd><p>data type for the description of bound</p><p>The <code>id</code> field records which input constraint the bound is the result of. The <code>scale</code> field is used to generate correct certificates in case the input constraint was of the form <code>2.x &lt;= 2</code>. The <code>bv</code> field is the actual value of the bound of the variable.</p></dd></dl><div class="spec module" id="module-Cs"><a href="#module-Cs" class="anchor"></a><code><span class="keyword">module</span> Cs = <a href="../Vpl/Cstr/index.html#module-Rat">Vpl.Cstr.Rat</a></code></div><div class="spec module" id="module-Vec"><a href="#module-Vec" class="anchor"></a><code><span class="keyword">module</span> <a href="Vec/index.html">Vec</a> = <a href="../Vpl__Cstr/Rat/index.html#module-Vec">Cs.Vec</a></code></div><dl><dt class="spec value" id="val-get_id"><a href="#val-get_id" class="anchor"></a><code><span class="keyword">val</span> get_id : <a href="index.html#type-bnd_t">bnd_t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>accessor for the <code>id</code> field of a value of type <code>bnd_t</code></p></dd></dl><dl><dt class="spec value" id="val-get_scale"><a href="#val-get_scale" class="anchor"></a><code><span class="keyword">val</span> get_scale : <a href="index.html#type-bnd_t">bnd_t</a> <span>&#45;&gt;</span> <a href="../Vpl/Scalar/Rat/index.html#type-t">Vpl.Scalar.Rat.t</a></code></dt><dd><p>accessor for the <code>scale</code> field of a value of type <code>bnd_t</code></p></dd></dl><dl><dt class="spec value" id="val-get_bv"><a href="#val-get_bv" class="anchor"></a><code><span class="keyword">val</span> get_bv : <a href="index.html#type-bnd_t">bnd_t</a> <span>&#45;&gt;</span> <a href="../Vpl/Scalar/Symbolic/index.html#type-t">Vpl.Scalar.Symbolic.t</a></code></dt><dd><p>accessor for the <code>bv</code> field of a value of type <code>bnd_t</code></p></dd></dl><dl><dt class="spec value" id="val-bnd_equal"><a href="#val-bnd_equal" class="anchor"></a><code><span class="keyword">val</span> bnd_equal : <a href="index.html#type-bnd_t">bnd_t</a> <span>&#45;&gt;</span> <a href="index.html#type-bnd_t">bnd_t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>equality test on values of type <code>bnd_t</code>.</p></dd></dl><dl><dt class="spec value" id="val-obnd_equal"><a href="#val-obnd_equal" class="anchor"></a><code><span class="keyword">val</span> obnd_equal : <span><a href="index.html#type-bnd_t">bnd_t</a> option</span> <span>&#45;&gt;</span> <span><a href="index.html#type-bnd_t">bnd_t</a> option</span> <span>&#45;&gt;</span> bool</code></dt><dd><p>equality test on values of type <code>bnd_t option</code>.</p></dd></dl><dl><dt class="spec type" id="type-state_t"><a href="#type-state_t" class="anchor"></a><code><span class="keyword">type</span> state_t</code><code> = </code><code>{</code><table class="record"><tr id="type-state_t.v" class="anchored"><td class="def field"><a href="#type-state_t.v" class="anchor"></a><code>v : <a href="../Vpl/Scalar/Symbolic/index.html#type-t">Vpl.Scalar.Symbolic.t</a>;</code></td></tr><tr id="type-state_t.low" class="anchored"><td class="def field"><a href="#type-state_t.low" class="anchor"></a><code>low : <span><a href="index.html#type-bnd_t">bnd_t</a> option</span>;</code></td></tr><tr id="type-state_t.up" class="anchored"><td class="def field"><a href="#type-state_t.up" class="anchor"></a><code>up : <span><a href="index.html#type-bnd_t">bnd_t</a> option</span>;</code></td></tr></table><code>}</code></dt></dl><dl><dt class="spec value" id="val-get_v"><a href="#val-get_v" class="anchor"></a><code><span class="keyword">val</span> get_v : <a href="index.html#type-state_t">state_t</a> <span>&#45;&gt;</span> <a href="../Vpl/Scalar/Symbolic/index.html#type-t">Vpl.Scalar.Symbolic.t</a></code></dt><dt class="spec value" id="val-get_low"><a href="#val-get_low" class="anchor"></a><code><span class="keyword">val</span> get_low : <a href="index.html#type-state_t">state_t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-bnd_t">bnd_t</a> option</span></code></dt><dt class="spec value" id="val-get_up"><a href="#val-get_up" class="anchor"></a><code><span class="keyword">val</span> get_up : <a href="index.html#type-state_t">state_t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-bnd_t">bnd_t</a> option</span></code></dt><dt class="spec value" id="val-state_equal"><a href="#val-state_equal" class="anchor"></a><code><span class="keyword">val</span> state_equal : <a href="index.html#type-state_t">state_t</a> <span>&#45;&gt;</span> <a href="index.html#type-state_t">state_t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>equality test on values of type <code>state_t</code>.</p></dd></dl><div class="spec module" id="module-Defs"><a href="#module-Defs" class="anchor"></a><code><span class="keyword">module</span> <a href="Defs/index.html">Defs</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code><code> = </code><code>{</code><table class="record"><tr id="type-t.mat" class="anchored"><td class="def field"><a href="#type-t.mat" class="anchor"></a><code>mat : <span><span><a href="../Vpl__Vector/Rat/index.html#type-t">Vec.t</a> option</span> <a href="../Vpl/Rtree/index.html#type-t">Vpl.Rtree.t</a></span>;</code></td></tr><tr id="type-t.state" class="anchored"><td class="def field"><a href="#type-t.state" class="anchor"></a><code>state : <span><a href="index.html#type-state_t">state_t</a> <a href="../Vpl/Rtree/index.html#type-t">Vpl.Rtree.t</a></span>;</code></td></tr><tr id="type-t.vars" class="anchored"><td class="def field"><a href="#type-t.vars" class="anchor"></a><code>vars : <a href="../Vpl__Var/index.html#module-Set">Vpl.Var.Set</a>.t;</code></td></tr><tr id="type-t.defs" class="anchored"><td class="def field"><a href="#type-t.defs" class="anchor"></a><code>defs : <a href="Defs/index.html#type-t">Defs.t</a>;</code></td></tr><tr id="type-t.nxt" class="anchored"><td class="def field"><a href="#type-t.nxt" class="anchor"></a><code>nxt : <a href="../Vpl/Var/index.html#type-t">Vpl.Var.t</a>;</code></td></tr></table><code>}</code></dt><dd><p>The type of a simplex tableau.</p></dd></dl><dl><dt class="spec value" id="val-get_mat"><a href="#val-get_mat" class="anchor"></a><code><span class="keyword">val</span> get_mat : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><span><a href="../Vpl__Vector/Rat/index.html#type-t">Vec.t</a> option</span> <a href="../Vpl/Rtree/index.html#type-t">Vpl.Rtree.t</a></span></code></dt><dt class="spec value" id="val-get_state"><a href="#val-get_state" class="anchor"></a><code><span class="keyword">val</span> get_state : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-state_t">state_t</a> <a href="../Vpl/Rtree/index.html#type-t">Vpl.Rtree.t</a></span></code></dt><dt class="spec value" id="val-getVars"><a href="#val-getVars" class="anchor"></a><code><span class="keyword">val</span> getVars : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Vpl__Var/index.html#module-Set">Vpl.Var.Set</a>.t</code></dt><dt class="spec value" id="val-get_nxt"><a href="#val-get_nxt" class="anchor"></a><code><span class="keyword">val</span> get_nxt : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Vpl/Var/index.html#type-t">Vpl.Var.t</a></code></dt></dl><div class="spec module" id="module-Witness"><a href="#module-Witness" class="anchor"></a><code><span class="keyword">module</span> <a href="Witness/index.html">Witness</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec type" id="type-witness_t"><a href="#type-witness_t" class="anchor"></a><code><span class="keyword">type</span> witness_t</code><code> = <a href="Witness/index.html#type-t">Witness.t</a></code></dt><dt class="spec type" id="type-mayUnsatT"><a href="#type-mayUnsatT" class="anchor"></a><code><span class="keyword">type</span> <span>'a mayUnsatT</span></code><code> = </code><table class="variant"><tr id="type-mayUnsatT.IsOk" class="anchored"><td class="def constructor"><a href="#type-mayUnsatT.IsOk" class="anchor"></a><code>| </code><code><span class="constructor">IsOk</span> <span class="keyword">of</span> <span class="type-var">'a</span></code></td></tr><tr id="type-mayUnsatT.IsUnsat" class="anchored"><td class="def constructor"><a href="#type-mayUnsatT.IsUnsat" class="anchor"></a><code>| </code><code><span class="constructor">IsUnsat</span> <span class="keyword">of</span> <a href="index.html#type-witness_t">witness_t</a></code></td></tr></table></dt></dl><dl><dt class="spec value" id="val-add"><a href="#val-add" class="anchor"></a><code><span class="keyword">val</span> add : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>(int * <a href="../Vpl__Cstr/Rat/index.html#type-t">Cs.t</a>)</span> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="index.html#type-mayUnsatT">mayUnsatT</a></span></code></dt><dd><p><code>add s (id, c)</code> adds contraints <code>c</code>, identified by <code>id</code>, to the simplex problem <code>s</code>.</p><p><code>add</code> assumes, but does not check, that <code>id</code> uniquely identifies <code>c</code>. If the addition of <code>c</code> to the simplex problem makes it unsatisfiable, <code>add</code> may or may not return <code>IsUnsat w</code>, where <code>w</code> describes a linear combination of the input constraints yielding a contradiction, otherwise, the updated problem is returned.</p><p>In the current implementation, <code>IsUnsat</code> is only returned when specifying incompatible bounds on single variables, e.g. <code>x &lt; 1</code> and <code>x &gt; 1</code>.</p></dd></dl><dl><dt class="spec value" id="val-addAcc"><a href="#val-addAcc" class="anchor"></a><code><span class="keyword">val</span> addAcc : <span><a href="index.html#type-t">t</a> <a href="index.html#type-mayUnsatT">mayUnsatT</a></span> <span>&#45;&gt;</span> <span>(int * <a href="../Vpl__Cstr/Rat/index.html#type-t">Cs.t</a>)</span> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="index.html#type-mayUnsatT">mayUnsatT</a></span></code></dt><dd><p><code>addAcc</code> is a convenience wrapper around <code>add</code> which propagates <code>IsUnsat</code> or performs the addition using <code>add</code> as necessary.</p></dd></dl><dl><dt class="spec value" id="val-mk"><a href="#val-mk" class="anchor"></a><code><span class="keyword">val</span> mk : <a href="../Vpl/Var/index.html#type-t">Vpl.Var.t</a> <span>&#45;&gt;</span> <span><span>(int * <a href="../Vpl__Cstr/Rat/index.html#type-t">Cs.t</a>)</span> list</span> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="index.html#type-mayUnsatT">mayUnsatT</a></span></code></dt><dd><p><code>mk lim l</code> builds a new simplex problem, composed of the constraints in <code>l</code>.</p><p>Variable <code>lim</code> specifies a frame beyond which fresh variables can be allocated, using <code>Var.next</code>. Note that <code>lim</code> itself may be used as a fresh variable. There is no possibility to change the frame after a simplex data structure has been created using <code>mk</code>: all the constraints ever added to the result of <code>mk</code> should have their variables &quot;smaller&quot; than <code>lim</code>.</p><p><code>mk</code> is implemented in terms of <code>add</code> and has the same behaviour regarding <code>IsUnsat</code> return values.</p></dd></dl><dl><dt class="spec value" id="val-check"><a href="#val-check" class="anchor"></a><code><span class="keyword">val</span> check : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="index.html#type-mayUnsatT">mayUnsatT</a></span></code></dt><dd><p>Look for an assignment of the variables of the problem which satisfies all the constraints. If such an assignment is found, the last simplex tableau is returned. If no such assignment exist, an unsatifiability witness is returned which describes a linear combination of the input constraints yielding a contradiction.</p></dd></dl><dl><dt class="spec value" id="val-checkFromAdd"><a href="#val-checkFromAdd" class="anchor"></a><code><span class="keyword">val</span> checkFromAdd : <span><a href="index.html#type-t">t</a> <a href="index.html#type-mayUnsatT">mayUnsatT</a></span> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="index.html#type-mayUnsatT">mayUnsatT</a></span></code></dt><dd><p>convenience wrapper around <code>check</code> which propagate unsatifiability or checks satisfiability as required</p></dd></dl><dl><dt class="spec value" id="val-getAsg"><a href="#val-getAsg" class="anchor"></a><code><span class="keyword">val</span> getAsg : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Vpl/Vector/Symbolic/index.html#type-t">Vpl.Vector.Symbolic.t</a></code></dt><dd><p>Get an assignment of the variables which satisfies the input constraints. Calling <code>getAsg</code> is only meaningful on a value of type <code>t</code> returned by <code>check</code> or <code>checkFromAdd</code>.</p></dd></dl><dl><dt class="spec value" id="val-insertBack"><a href="#val-insertBack" class="anchor"></a><code><span class="keyword">val</span> insertBack : <a href="../Vpl/Var/index.html#type-t">Vpl.Var.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-compl"><a href="#val-compl" class="anchor"></a><code><span class="keyword">val</span> compl : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-stricten"><a href="#val-stricten" class="anchor"></a><code><span class="keyword">val</span> stricten : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="index.html#type-mayUnsatT">mayUnsatT</a></span></code></dt><dt class="spec value" id="val-forget"><a href="#val-forget" class="anchor"></a><code><span class="keyword">val</span> forget : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-pr"><a href="#val-pr" class="anchor"></a><code><span class="keyword">val</span> pr : <span>(<a href="../Vpl/Var/index.html#type-t">Vpl.Var.t</a> <span>&#45;&gt;</span> string)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p>Pretty-print an element of type <code>t</code>. The function <code>pr</code> wraps functions <code>prMat</code> and <code>prState</code>.</p></dd></dl><dl><dt class="spec value" id="val-prMat"><a href="#val-prMat" class="anchor"></a><code><span class="keyword">val</span> prMat : <span>(<a href="../Vpl/Var/index.html#type-t">Vpl.Var.t</a> <span>&#45;&gt;</span> string)</span> <span>&#45;&gt;</span> <span><span><a href="../Vpl__Vector/Rat/index.html#type-t">Vec.t</a> option</span> <a href="../Vpl/Rtree/index.html#type-t">Vpl.Rtree.t</a></span> <span>&#45;&gt;</span> string</code></dt><dd><p><code>prMat s</code> pretty-prints the constraint matrix (field <code>mat</code>) of <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-prState"><a href="#val-prState" class="anchor"></a><code><span class="keyword">val</span> prState : <span>(<a href="../Vpl/Var/index.html#type-t">Vpl.Var.t</a> <span>&#45;&gt;</span> string)</span> <span>&#45;&gt;</span> <span><a href="index.html#type-state_t">state_t</a> <a href="../Vpl/Rtree/index.html#type-t">Vpl.Rtree.t</a></span> <span>&#45;&gt;</span> string</code></dt><dd><p><code>prState s</code> pretty-prints the bounds and values on variables (field <code>state</code>) of <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-prBnd"><a href="#val-prBnd" class="anchor"></a><code><span class="keyword">val</span> prBnd : <span><a href="index.html#type-bnd_t">bnd_t</a> option</span> <span>&#45;&gt;</span> string</code></dt><dd><p>Pretty-print an element of type <code>bnd_t option</code>.</p></dd></dl><dl><dt class="spec value" id="val-prSt"><a href="#val-prSt" class="anchor"></a><code><span class="keyword">val</span> prSt : <a href="index.html#type-state_t">state_t</a> <span>&#45;&gt;</span> string</code></dt><dd><p>Pretty-print an element of type <code>state_t</code>.</p></dd></dl></div></body></html>