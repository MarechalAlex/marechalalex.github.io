<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Vpl__Flags (vpl-core.Vpl__Flags)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">vpl-core</a> &#x00BB; Vpl__Flags</nav><h1>Module <code>Vpl__Flags</code></h1><p>This module allows to tune the algorithms used in the polyhedral operators.</p></header><dl><dt class="spec type" id="type-scalar"><a href="#type-scalar" class="anchor"></a><code><span class="keyword">type</span> scalar</code><code> = </code><table class="variant"><tr id="type-scalar.Rat" class="anchored"><td class="def constructor"><a href="#type-scalar.Rat" class="anchor"></a><code>| </code><code><span class="constructor">Rat</span></code></td></tr><tr id="type-scalar.Symbolic" class="anchored"><td class="def constructor"><a href="#type-scalar.Symbolic" class="anchor"></a><code>| </code><code><span class="constructor">Symbolic</span></code></td></tr><tr id="type-scalar.Float" class="anchored"><td class="def constructor"><a href="#type-scalar.Float" class="anchor"></a><code>| </code><code><span class="constructor">Float</span></code></td></tr></table></dt><dd><p>Choice of the point type.</p><ul><li><code>Rat</code>: Rational points</li><li><code>Symbolic</code>: Rational points with symbolic error</li><li><code>Float</code>: Floating points</li></ul></dd></dl><dl><dt class="spec value" id="val-scalar_to_string"><a href="#val-scalar_to_string" class="anchor"></a><code><span class="keyword">val</span> scalar_to_string : <a href="index.html#type-scalar">scalar</a> <span>&#45;&gt;</span> string</code></dt><dt class="spec value" id="val-scalar_to_xml"><a href="#val-scalar_to_xml" class="anchor"></a><code><span class="keyword">val</span> scalar_to_xml : <a href="index.html#type-scalar">scalar</a> <span>&#45;&gt;</span> string</code></dt></dl><dl><dt class="spec type" id="type-proj_method"><a href="#type-proj_method" class="anchor"></a><code><span class="keyword">type</span> proj_method</code><code> = </code><table class="variant"><tr id="type-proj_method.FM" class="anchored"><td class="def constructor"><a href="#type-proj_method.FM" class="anchor"></a><code>| </code><code><span class="constructor">FM</span></code></td></tr><tr id="type-proj_method.Proj_PLP" class="anchored"><td class="def constructor"><a href="#type-proj_method.Proj_PLP" class="anchor"></a><code>| </code><code><span class="constructor">Proj_PLP</span> <span class="keyword">of</span> <a href="index.html#type-scalar">scalar</a></code></td></tr><tr id="type-proj_method.PHeuristic" class="anchored"><td class="def constructor"><a href="#type-proj_method.PHeuristic" class="anchor"></a><code>| </code><code><span class="constructor">PHeuristic</span></code></td></tr></table></dt><dd><p>Choice of the projection method.</p><ul><li><code>FM</code>: classical way that uses the Fourier-Motzkin algorithm</li><li><code>Proj_PLP</code>: method based on Parametric Linear Programming</li></ul></dd></dl><dl><dt class="spec type" id="type-join_method"><a href="#type-join_method" class="anchor"></a><code><span class="keyword">type</span> join_method</code><code> = </code><table class="variant"><tr id="type-join_method.Baryc" class="anchored"><td class="def constructor"><a href="#type-join_method.Baryc" class="anchor"></a><code>| </code><code><span class="constructor">Baryc</span></code></td></tr><tr id="type-join_method.Join_PLP" class="anchored"><td class="def constructor"><a href="#type-join_method.Join_PLP" class="anchor"></a><code>| </code><code><span class="constructor">Join_PLP</span> <span class="keyword">of</span> <a href="index.html#type-scalar">scalar</a></code></td></tr><tr id="type-join_method.JHeuristic" class="anchored"><td class="def constructor"><a href="#type-join_method.JHeuristic" class="anchor"></a><code>| </code><code><span class="constructor">JHeuristic</span></code></td></tr><tr id="type-join_method.Join_fromRegions" class="anchored"><td class="def constructor"><a href="#type-join_method.Join_fromRegions" class="anchor"></a><code>| </code><code><span class="constructor">Join_fromRegions</span></code></td></tr></table></dt><dd><p>Choice of the join method.</p><ul><li><code>Baryc</code>: algorithm based on convex combinations + projection</li><li><code>Join_PLP</code>: method based on Parametric Linear Programming</li></ul></dd></dl><dl><dt class="spec value" id="val-proj"><a href="#val-proj" class="anchor"></a><code><span class="keyword">val</span> proj : <span><a href="index.html#type-proj_method">proj_method</a> Stdlib.ref</span></code></dt><dd><p>Default choice for projection.</p></dd></dl><dl><dt class="spec value" id="val-proj_to_string"><a href="#val-proj_to_string" class="anchor"></a><code><span class="keyword">val</span> proj_to_string : unit <span>&#45;&gt;</span> string</code></dt><dt class="spec value" id="val-proj_to_xml"><a href="#val-proj_to_xml" class="anchor"></a><code><span class="keyword">val</span> proj_to_xml : unit <span>&#45;&gt;</span> string</code></dt><dt class="spec value" id="val-join"><a href="#val-join" class="anchor"></a><code><span class="keyword">val</span> join : <span><a href="index.html#type-join_method">join_method</a> Stdlib.ref</span></code></dt><dd><p>Default choice for join.</p></dd></dl><dl><dt class="spec value" id="val-join_to_string"><a href="#val-join_to_string" class="anchor"></a><code><span class="keyword">val</span> join_to_string : unit <span>&#45;&gt;</span> string</code></dt><dt class="spec value" id="val-join_to_xml"><a href="#val-join_to_xml" class="anchor"></a><code><span class="keyword">val</span> join_to_xml : unit <span>&#45;&gt;</span> string</code></dt><dt class="spec value" id="val-handelman_loop"><a href="#val-handelman_loop" class="anchor"></a><code><span class="keyword">val</span> handelman_loop : <span>bool Stdlib.ref</span></code></dt><dd><p>If set to true, the Handelman linearization will loop, meaning that it will iterate on the last result obtained. The linearization of polynomial <code>g</code> on the starting polyhedron <code>P</code> will give H_0 = linearize(P,g) H_i = linearize(H_(i-1), g)</p></dd></dl><dl><dt class="spec value" id="val-handelman_timeout"><a href="#val-handelman_timeout" class="anchor"></a><code><span class="keyword">val</span> handelman_timeout : <span><span>int option</span> Stdlib.ref</span></code></dt><dd><p>Sets a timeout to the Handelman linearization. Combined to <a href="index.html#val-handelman_loop"><code>handelman_loop</code></a>, the linearization returns the last result found.</p></dd></dl><dl><dt class="spec value" id="val-handelman_normalize"><a href="#val-handelman_normalize" class="anchor"></a><code><span class="keyword">val</span> handelman_normalize : <span><span><a href="../Vpl/Scalar/Rat/index.html#type-t">Vpl.Scalar.Rat.t</a> option</span> Stdlib.ref</span></code></dt><dd><p>Sets a normalization constant. If <code>None</code>, there will be no normalization.</p></dd></dl><dl><dt class="spec value" id="val-distributed_plp"><a href="#val-distributed_plp" class="anchor"></a><code><span class="keyword">val</span> distributed_plp : <span><span>int option</span> Stdlib.ref</span></code></dt><dd><p>If set to <code>Some n</code>, the parametric simplex will be distributed over n processes.</p></dd></dl><dl><dt class="spec value" id="val-row_echelon_equalities"><a href="#val-row_echelon_equalities" class="anchor"></a><code><span class="keyword">val</span> row_echelon_equalities : <span>bool Stdlib.ref</span></code></dt><dd><p>If set to <code>true</code>, the system of equalities of a polyhedron will be in row echelon form.</p></dd></dl><dl><dt class="spec type" id="type-plp_method"><a href="#type-plp_method" class="anchor"></a><code><span class="keyword">type</span> plp_method</code><code> = </code><table class="variant"><tr id="type-plp_method.Adj_Raytracing" class="anchored"><td class="def constructor"><a href="#type-plp_method.Adj_Raytracing" class="anchor"></a><code>| </code><code><span class="constructor">Adj_Raytracing</span></code></td></tr><tr id="type-plp_method.Adj_Raytracing_min" class="anchored"><td class="def constructor"><a href="#type-plp_method.Adj_Raytracing_min" class="anchor"></a><code>| </code><code><span class="constructor">Adj_Raytracing_min</span></code></td></tr><tr id="type-plp_method.Greedy" class="anchored"><td class="def constructor"><a href="#type-plp_method.Greedy" class="anchor"></a><code>| </code><code><span class="constructor">Greedy</span></code></td></tr></table></dt></dl><dl><dt class="spec value" id="val-plp"><a href="#val-plp" class="anchor"></a><code><span class="keyword">val</span> plp : <span><a href="index.html#type-plp_method">plp_method</a> Stdlib.ref</span></code></dt><dt class="spec value" id="val-plp_to_string"><a href="#val-plp_to_string" class="anchor"></a><code><span class="keyword">val</span> plp_to_string : unit <span>&#45;&gt;</span> string</code></dt><dt class="spec value" id="val-plp_to_xml"><a href="#val-plp_to_xml" class="anchor"></a><code><span class="keyword">val</span> plp_to_xml : unit <span>&#45;&gt;</span> string</code></dt><dt class="spec value" id="val-log_trace"><a href="#val-log_trace" class="anchor"></a><code><span class="keyword">val</span> log_trace : <span>bool Stdlib.ref</span></code></dt><dd><p>Enabling of log traces.</p></dd></dl><dl><dt class="spec value" id="val-sum_lambda_1"><a href="#val-sum_lambda_1" class="anchor"></a><code><span class="keyword">val</span> sum_lambda_1 : <span>bool Stdlib.ref</span></code></dt><dd><p>If <code>true</code>, put sum lambda = 1 as normalization constraint in the projection via PLP.</p></dd></dl><dl><dt class="spec type" id="type-lin_method"><a href="#type-lin_method" class="anchor"></a><code><span class="keyword">type</span> lin_method</code><code> = </code><table class="variant"><tr id="type-lin_method.Intervalization" class="anchored"><td class="def constructor"><a href="#type-lin_method.Intervalization" class="anchor"></a><code>| </code><code><span class="constructor">Intervalization</span></code></td></tr><tr id="type-lin_method.Handelman" class="anchored"><td class="def constructor"><a href="#type-lin_method.Handelman" class="anchor"></a><code>| </code><code><span class="constructor">Handelman</span></code></td></tr><tr id="type-lin_method.Both" class="anchored"><td class="def constructor"><a href="#type-lin_method.Both" class="anchor"></a><code>| </code><code><span class="constructor">Both</span></code></td></tr></table></dt></dl><dl><dt class="spec value" id="val-lin"><a href="#val-lin" class="anchor"></a><code><span class="keyword">val</span> lin : <span><a href="index.html#type-lin_method">lin_method</a> Stdlib.ref</span></code></dt><dt class="spec value" id="val-smart_proj_incl"><a href="#val-smart_proj_incl" class="anchor"></a><code><span class="keyword">val</span> smart_proj_incl : <span>bool Stdlib.ref</span></code></dt><dd><p>If set to <code>true</code>, the <code>proj_incl</code> operator will use the smart PLP operator. Otherwise, it computes the projection, then tests the inclusion.</p></dd></dl></div></body></html>