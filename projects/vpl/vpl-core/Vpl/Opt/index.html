<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Opt (vpl-core.Vpl.Opt)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">vpl-core</a> &#x00BB; <a href="../index.html">Vpl</a> &#x00BB; Opt</nav><h1>Module <code>Vpl.Opt</code></h1></header><aside><p>This module builds on <a href="../Splx/index.html"><code>Splx</code></a> to offer an optimizing simplex.</p></aside><div class="spec module" id="module-Debug"><a href="#module-Debug" class="anchor"></a><code><span class="keyword">module</span> <a href="Debug/index.html">Debug</a> : <a href="../DebugTypes/index.html#module-type-Type">DebugTypes.Type</a></code></div><dl><dt class="spec type" id="type-progressT"><a href="#type-progressT" class="anchor"></a><code><span class="keyword">type</span> progressT</code><code> = </code><table class="variant"><tr id="type-progressT.Unbnd" class="anchored"><td class="def constructor"><a href="#type-progressT.Unbnd" class="anchor"></a><code>| </code><code><span class="constructor">Unbnd</span></code></td></tr><tr id="type-progressT.UpTo" class="anchored"><td class="def constructor"><a href="#type-progressT.UpTo" class="anchor"></a><code>| </code><code><span class="constructor">UpTo</span> <span class="keyword">of</span> <a href="../Scalar/Symbolic/index.html#type-t">Scalar.Symbolic.t</a></code></td></tr><tr id="type-progressT.NoChange" class="anchored"><td class="def constructor"><a href="#type-progressT.NoChange" class="anchor"></a><code>| </code><code><span class="constructor">NoChange</span></code></td></tr></table></dt><dd><p>A value of type <code>progressT</code> describes the change that can be operated on a given quantity. The change does not specify whether this is an increase or a decrease. In the case of <code>UpTo d</code>, the change <code>d</code> is always positive.</p></dd></dl><dl><dt class="spec type" id="type-dirT"><a href="#type-dirT" class="anchor"></a><code><span class="keyword">type</span> dirT</code><code> = </code><table class="variant"><tr id="type-dirT.Incr" class="anchored"><td class="def constructor"><a href="#type-dirT.Incr" class="anchor"></a><code>| </code><code><span class="constructor">Incr</span></code></td></tr><tr id="type-dirT.Decr" class="anchored"><td class="def constructor"><a href="#type-dirT.Decr" class="anchor"></a><code>| </code><code><span class="constructor">Decr</span></code></td></tr></table></dt><dd><p>Describe the direction of a value change: increasing or decreasing.</p></dd></dl><dl><dt class="spec type" id="type-actionT"><a href="#type-actionT" class="anchor"></a><code><span class="keyword">type</span> actionT</code><code> = </code><table class="variant"><tr id="type-actionT.Done" class="anchored"><td class="def constructor"><a href="#type-actionT.Done" class="anchor"></a><code>| </code><code><span class="constructor">Done</span></code></td></tr><tr id="type-actionT.Move" class="anchored"><td class="def constructor"><a href="#type-actionT.Move" class="anchor"></a><code>| </code><code><span class="constructor">Move</span> <span class="keyword">of</span> <a href="../Var/index.html#type-t">Var.t</a> * <a href="index.html#type-dirT">dirT</a> * <a href="index.html#type-progressT">progressT</a></code></td></tr></table></dt><dd><p>During the optimization, a value of type <code>actionT</code> decribes the choice on the course of actions, based on the contents of the objective line. <code>Done</code> means that the optimal value for the objective function is reached. <code>Move (v, d, p)</code> means that adjusting the value of the variable <code>v</code>, in direction <code>d</code>, will increase the value of the objective function. In the latter case, the bounds on <code>v</code> limit its change according to <code>p</code>.</p></dd></dl><dl><dt class="spec type" id="type-nextT"><a href="#type-nextT" class="anchor"></a><code><span class="keyword">type</span> nextT</code><code> = </code><table class="variant"><tr id="type-nextT.OptFinite" class="anchored"><td class="def constructor"><a href="#type-nextT.OptFinite" class="anchor"></a><code>| </code><code><span class="constructor">OptFinite</span> <span class="keyword">of</span> <a href="../Scalar/Symbolic/index.html#type-t">Scalar.Symbolic.t</a></code></td></tr><tr id="type-nextT.OptUnbnd" class="anchored"><td class="def constructor"><a href="#type-nextT.OptUnbnd" class="anchor"></a><code>| </code><code><span class="constructor">OptUnbnd</span></code></td></tr><tr id="type-nextT.GoOn" class="anchored"><td class="def constructor"><a href="#type-nextT.GoOn" class="anchor"></a><code>| </code><code><span class="constructor">GoOn</span> <span class="keyword">of</span> <a href="../Splx/index.html#type-t">Splx.t</a></code></td></tr></table></dt><dd><p>At the end of each pivoting step, decide whether the optimum is reached or progress still needs to be made.</p></dd></dl><dl><dt class="spec type" id="type-optT"><a href="#type-optT" class="anchor"></a><code><span class="keyword">type</span> optT</code><code> = </code><table class="variant"><tr id="type-optT.Finite" class="anchored"><td class="def constructor"><a href="#type-optT.Finite" class="anchor"></a><code>| </code><code><span class="constructor">Finite</span> <span class="keyword">of</span> <a href="../Splx/index.html#type-t">Splx.t</a> * <a href="../Scalar/Rat/index.html#type-t">Scalar.Rat.t</a> * <a href="../Splx/index.html#type-witness_t">Splx.witness_t</a></code></td><td class="doc"><p>The optimized form can take values up to and including the given value.</p></td></tr><tr id="type-optT.Sup" class="anchored"><td class="def constructor"><a href="#type-optT.Sup" class="anchor"></a><code>| </code><code><span class="constructor">Sup</span> <span class="keyword">of</span> <a href="../Splx/index.html#type-t">Splx.t</a> * <a href="../Scalar/Rat/index.html#type-t">Scalar.Rat.t</a> * <a href="../Splx/index.html#type-witness_t">Splx.witness_t</a></code></td><td class="doc"><p>The optimized form can take values up to and excluding the given value.</p></td></tr><tr id="type-optT.Infty" class="anchored"><td class="def constructor"><a href="#type-optT.Infty" class="anchor"></a><code>| </code><code><span class="constructor">Infty</span></code></td><td class="doc"><p>The optimized form is unbounded.</p></td></tr></table></dt><dd><p>This is the result type of the optimization.</p></dd></dl><dl><dt class="spec value" id="val-max"><a href="#val-max" class="anchor"></a><code><span class="keyword">val</span> max : <a href="../Splx/index.html#type-t">Splx.t</a> <span>&#45;&gt;</span> <a href="../../Vpl__Vector/Rat/index.html#type-t">Splx.Vec.t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-optT">optT</a> <a href="../Splx/index.html#type-mayUnsatT">Splx.mayUnsatT</a></span></code></dt><dd><p>maximize a linear form under a set of constraints</p><p><code>max</code> returns either a description of the optimum for the given linear form or an unsatifiability witness if the constraint system is not satisfiable.</p><p>The simplex tableau may be built using functions <code>add</code> or <code>mk</code>, but <code>check</code> must not be called on it prior to calling <code>max</code> as <code>check</code> performs simplifications possible for satifiability checking, but not for optimization.</p></dd></dl><dl><dt class="spec value" id="val-max'"><a href="#val-max'" class="anchor"></a><code><span class="keyword">val</span> max' : <span><a href="../Splx/index.html#type-t">Splx.t</a> <a href="../Splx/index.html#type-mayUnsatT">Splx.mayUnsatT</a></span> <span>&#45;&gt;</span> <a href="../../Vpl__Vector/Rat/index.html#type-t">Splx.Vec.t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-optT">optT</a> <a href="../Splx/index.html#type-mayUnsatT">Splx.mayUnsatT</a></span></code></dt><dd><p>convenience wrapper around <code>max</code> for direct use on the result of functions <code>add</code> or <code>mk</code></p></dd></dl><dl><dt class="spec value" id="val-prProgress"><a href="#val-prProgress" class="anchor"></a><code><span class="keyword">val</span> prProgress : <a href="index.html#type-progressT">progressT</a> <span>&#45;&gt;</span> string</code></dt><dd><p>Pretty-print a value of type <code>progressT</code>.</p></dd></dl><dl><dt class="spec value" id="val-prDir"><a href="#val-prDir" class="anchor"></a><code><span class="keyword">val</span> prDir : <a href="index.html#type-dirT">dirT</a> <span>&#45;&gt;</span> string</code></dt><dd><p>Pretty-print a value of type <code>dirT</code>.</p></dd></dl><dl><dt class="spec value" id="val-prAction"><a href="#val-prAction" class="anchor"></a><code><span class="keyword">val</span> prAction : <span>(<a href="../Var/index.html#type-t">Var.t</a> <span>&#45;&gt;</span> string)</span> <span>&#45;&gt;</span> <a href="index.html#type-actionT">actionT</a> <span>&#45;&gt;</span> string</code></dt><dd><p>Pretty-print a value of type <code>actionT</code>. The provided basis must be the one in which the non-basic variable is defined.</p></dd></dl><dl><dt class="spec value" id="val-prNext"><a href="#val-prNext" class="anchor"></a><code><span class="keyword">val</span> prNext : <span>(<a href="../Var/index.html#type-t">Var.t</a> <span>&#45;&gt;</span> string)</span> <span>&#45;&gt;</span> <a href="index.html#type-nextT">nextT</a> <span>&#45;&gt;</span> string</code></dt><dd><p>Pretty-print a value of type <code>nextT</code>.</p></dd></dl><dl><dt class="spec value" id="val-prOpt"><a href="#val-prOpt" class="anchor"></a><code><span class="keyword">val</span> prOpt : <a href="index.html#type-optT">optT</a> <span>&#45;&gt;</span> string</code></dt><dd><p>Pretty-print a value of type <code>optT</code>.</p></dd></dl><aside><p>The following function are internal functions which are exported for testing purposes only. They maintain the invariant on the simplex structure, which is that the value of all the variables should satisfy both their bounds and the constraints.</p></aside><dl><dt class="spec value" id="val-pickNBasic"><a href="#val-pickNBasic" class="anchor"></a><code><span class="keyword">val</span> pickNBasic : <a href="../Var/index.html#type-t">Var.t</a> <span>&#45;&gt;</span> <a href="../Splx/index.html#type-t">Splx.t</a> <span>&#45;&gt;</span> <a href="index.html#type-actionT">actionT</a></code></dt><dd><p><code>pickNBasic z s</code> observes the objective line of the simplex tableau, represented by the contraint of basic variable <code>z</code> and decides what should be done.</p></dd></dl><dl><dt class="spec value" id="val-pickBasic"><a href="#val-pickBasic" class="anchor"></a><code><span class="keyword">val</span> pickBasic : <a href="../Splx/index.html#type-t">Splx.t</a> <span>&#45;&gt;</span> <a href="../Var/index.html#type-t">Var.t</a> <span>&#45;&gt;</span> <a href="index.html#type-progressT">progressT</a> <span>&#45;&gt;</span> <a href="index.html#type-dirT">dirT</a> <span>&#45;&gt;</span> <a href="../Var/index.html#type-t">Var.t</a> * <a href="index.html#type-progressT">progressT</a></code></dt><dd><p><code>pickBasic s xN xNBnd dir</code> looks for the basic variable with which to pivot <code>xN</code>. The selected basic variable <code>xB</code> is the one which constrains the most the change of the value of <code>xN</code> in direction <code>dir</code>. The constraint on this change, <code>xNBnd1</code> is returned along with <code>xB</code>. The <code>xNBnd</code> argument is the constraint set on the change of the value of <code>xN</code> by the bounds of <code>xN</code>. If <code>xNBnd</code> is the most restrictive of all of the constraints imposed on the value of <code>xN</code>, then <code>xB</code> = <code>xN</code>.</p></dd></dl><dl><dt class="spec value" id="val-step"><a href="#val-step" class="anchor"></a><code><span class="keyword">val</span> step : <a href="../Var/index.html#type-t">Var.t</a> <span>&#45;&gt;</span> <a href="../Splx/index.html#type-t">Splx.t</a> <span>&#45;&gt;</span> <a href="index.html#type-nextT">nextT</a></code></dt><dd><p><code>step z s</code> does one optimization step: it chooses a non-basic variable which can be used to increase the value of the goal, it chooses a basic variable with which to pivot and finally pivots. It notices that the optimum is reached only if it is reached in <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-setObj"><a href="#val-setObj" class="anchor"></a><code><span class="keyword">val</span> setObj : <a href="../Splx/index.html#type-t">Splx.t</a> <span>&#45;&gt;</span> <a href="../../Vpl__Vector/Rat/index.html#type-t">Splx.Vec.t</a> <span>&#45;&gt;</span> <a href="../Var/index.html#type-t">Var.t</a> * <a href="../Splx/index.html#type-t">Splx.t</a></code></dt><dd><p><code>setObj s obj</code> sets <code>obj</code> as the linear form to optimize in <code>s</code> and returns the corresponding problem, along with the basic variable associated with <code>obj</code>.</p></dd></dl><dl><dt class="spec value" id="val-getAsg"><a href="#val-getAsg" class="anchor"></a><code><span class="keyword">val</span> getAsg : <a href="../Var/index.html#type-t">Var.t</a> <span>&#45;&gt;</span> <span><span>(int * <a href="../Cstr/Rat/index.html#type-t">Cstr.Rat.t</a>)</span> list</span> <span>&#45;&gt;</span> <span><span><a href="../Scalar/Symbolic/index.html#type-t">Scalar.Symbolic.t</a> <a href="../Rtree/index.html#type-t">Rtree.t</a></span> option</span></code></dt><dd><p>We maximize epsilon such that epsilon &lt;= 1 and for all constraint Ci, Ci &gt;= epsilon.</p></dd></dl><dl><dt class="spec value" id="val-getAsg_and_value"><a href="#val-getAsg_and_value" class="anchor"></a><code><span class="keyword">val</span> getAsg_and_value : <a href="../Var/index.html#type-t">Var.t</a> <span>&#45;&gt;</span> <span><span>(int * <a href="../Cstr/Rat/index.html#type-t">Cstr.Rat.t</a>)</span> list</span> <span>&#45;&gt;</span> <span><span>(<a href="../Vector/Symbolic/index.html#type-t">Vector.Symbolic.t</a> * <span><a href="../Scalar/Rat/index.html#type-t">Scalar.Rat.t</a> option</span>)</span> option</span></code></dt><dt class="spec value" id="val-getAsg_raw"><a href="#val-getAsg_raw" class="anchor"></a><code><span class="keyword">val</span> getAsg_raw : <span><a href="../Cstr/Rat/index.html#type-t">Cstr.Rat.t</a> list</span> <span>&#45;&gt;</span> <span><a href="../Vector/Symbolic/index.html#type-t">Vector.Symbolic.t</a> option</span></code></dt><dt class="spec value" id="val-getAsg_and_value_raw"><a href="#val-getAsg_and_value_raw" class="anchor"></a><code><span class="keyword">val</span> getAsg_and_value_raw : <span><a href="../Cstr/Rat/index.html#type-t">Cstr.Rat.t</a> list</span> <span>&#45;&gt;</span> <span><span>(<a href="../Vector/Symbolic/index.html#type-t">Vector.Symbolic.t</a> * <span><a href="../Scalar/Rat/index.html#type-t">Scalar.Rat.t</a> option</span>)</span> option</span></code></dt></dl></div></body></html>